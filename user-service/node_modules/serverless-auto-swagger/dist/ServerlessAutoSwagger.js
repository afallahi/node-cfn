'use strict';
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const typeconv_1 = require("typeconv");
const helperFunctions_1 = require("./helperFunctions");
const functions_1 = require("./resources/functions");
const customPropertiesSchema = require("./schemas/custom-properties.schema.json");
const functionEventPropertiesSchema = require("./schemas/function-event-properties.schema.json");
class ServerlessAutoSwagger {
    // IO is only injected in Serverless v3.0.0 (can experiment with `import { writeText, log, progress } from '@serverless/utils/log'; in a future PR)
    constructor(serverless, options, io) {
        var _a, _b;
        this.swagger = {
            swagger: '2.0',
            info: {
                title: '',
                version: '1',
            },
            paths: {},
            definitions: {},
            securityDefinitions: {},
        };
        this.commands = {};
        this.hooks = {};
        this.registerOptions = () => {
            var _a, _b, _c;
            // TODO: Test custom properties configuration
            (_a = this.serverless.configSchemaHandler) === null || _a === void 0 ? void 0 : _a.defineCustomProperties(customPropertiesSchema);
            (_b = this.serverless.configSchemaHandler) === null || _b === void 0 ? void 0 : _b.defineFunctionEventProperties('aws', 'http', functionEventPropertiesSchema);
            (_c = this.serverless.configSchemaHandler) === null || _c === void 0 ? void 0 : _c.defineFunctionEventProperties('aws', 'httpApi', functionEventPropertiesSchema);
        };
        this.preDeploy = async () => {
            var _a, _b, _c, _d, _e;
            const stage = this.serverless.service.provider.stage;
            const excludedStages = (_b = (_a = this.serverless.service.custom) === null || _a === void 0 ? void 0 : _a.autoswagger) === null || _b === void 0 ? void 0 : _b.excludeStages;
            if (excludedStages === null || excludedStages === void 0 ? void 0 : excludedStages.includes(stage)) {
                this.log.notice(`Swagger lambdas will not be deployed for stage [${stage}], as it has been marked for exclusion.`);
                return;
            }
            const generateSwaggerOnDeploy = (_e = (_d = (_c = this.serverless.service.custom) === null || _c === void 0 ? void 0 : _c.autoswagger) === null || _d === void 0 ? void 0 : _d.generateSwaggerOnDeploy) !== null && _e !== void 0 ? _e : true;
            if (generateSwaggerOnDeploy)
                await this.generateSwagger();
            this.addEndpointsAndLambda();
        };
        /** Updates this.swagger with serverless custom.autoswagger overrides */
        this.gatherSwaggerOverrides = () => {
            var _a, _b, _c;
            const autoswagger = (_b = (_a = this.serverless.service.custom) === null || _a === void 0 ? void 0 : _a.autoswagger) !== null && _b !== void 0 ? _b : {};
            if (autoswagger.basePath)
                this.swagger.basePath = autoswagger.basePath;
            if (autoswagger.host)
                this.swagger.host = autoswagger.host;
            if (autoswagger.schemes)
                this.swagger.schemes = autoswagger.schemes;
            if (autoswagger.title)
                this.swagger.info.title = autoswagger.title;
            if (autoswagger.description)
                this.swagger.info.description = autoswagger.description;
            if (autoswagger.version)
                this.swagger.info.version = autoswagger.version;
            // There must be at least one or this `if` will be false
            if ((_c = autoswagger.swaggerFiles) === null || _c === void 0 ? void 0 : _c.length)
                this.gatherSwaggerFiles(autoswagger.swaggerFiles);
        };
        /** Updates this.swagger with swagger file overrides */
        this.gatherSwaggerFiles = (swaggerFiles) => {
            swaggerFiles.forEach((filepath) => {
                const fileData = (0, fs_extra_1.readFileSync)(filepath, 'utf8');
                const jsonData = JSON.parse(fileData);
                const { paths = {}, definitions = {} } = jsonData, swagger = __rest(jsonData, ["paths", "definitions"]);
                this.swagger = Object.assign(Object.assign(Object.assign({}, this.swagger), swagger), { paths: Object.assign(Object.assign({}, this.swagger.paths), paths), definitions: Object.assign(Object.assign({}, this.swagger.definitions), definitions) });
            });
        };
        this.gatherTypes = async () => {
            var _a, _b;
            // get the details from the package.json? for info
            const service = this.serverless.service.service;
            if (typeof service === 'string')
                this.swagger.info.title = service;
            else
                this.swagger.info.title = service.name;
            const reader = (0, typeconv_1.getTypeScriptReader)();
            const writer = (0, typeconv_1.getOpenApiWriter)({
                format: 'json',
                title: this.swagger.info.title,
                version: 'v1',
                schemaVersion: '2.0',
            });
            const { convert } = (0, typeconv_1.makeConverter)(reader, writer);
            try {
                const typeLocationOverride = (_b = (_a = this.serverless.service.custom) === null || _a === void 0 ? void 0 : _a.autoswagger) === null || _b === void 0 ? void 0 : _b.typefiles;
                const typesFile = typeLocationOverride || ['./src/types/api-types.d.ts'];
                await Promise.all(typesFile.map(async (filepath) => {
                    try {
                        const fileData = (0, fs_extra_1.readFileSync)(filepath, 'utf8');
                        const { data } = await convert({ data: fileData });
                        // change the #/components/schema to #/definitions
                        const definitionsData = data.replace(/\/components\/schemas/g, '/definitions');
                        const definitions = JSON.parse(definitionsData).components.schemas;
                        // TODO: Handle `anyOf` in swagger configs
                        this.swagger.definitions = Object.assign(Object.assign({}, this.swagger.definitions), definitions);
                    }
                    catch (error) {
                        this.log.error(`Couldn't read types from file: ${filepath}`);
                        return;
                    }
                }));
                // TODO change this to store these as temporary and only include definitions used elsewhere.
            }
            catch (error) {
                this.log.error(`Unable to get types: ${error}`);
            }
        };
        this.generateSecurity = () => {
            var _a, _b;
            const apiKeyHeaders = (_b = (_a = this.serverless.service.custom) === null || _a === void 0 ? void 0 : _a.autoswagger) === null || _b === void 0 ? void 0 : _b.apiKeyHeaders;
            if (apiKeyHeaders === null || apiKeyHeaders === void 0 ? void 0 : apiKeyHeaders.length) {
                const securityDefinitions = {};
                apiKeyHeaders.forEach((indexName) => {
                    securityDefinitions[indexName] = {
                        type: 'apiKey',
                        name: indexName,
                        in: 'header',
                    };
                });
                this.swagger = Object.assign(Object.assign({}, this.swagger), { securityDefinitions });
            }
            // If no apiKeyHeaders are specified, we don't want to override any existing `securityDefinitions`
            //  that may be defined in a custom swagger json
        };
        this.generateSwagger = async () => {
            var _a;
            await this.gatherTypes();
            this.gatherSwaggerOverrides();
            this.generateSecurity();
            this.generatePaths();
            this.log.notice('Creating Swagger file...');
            // TODO enable user to specify swagger file path. also needs to update the swagger json endpoint.
            const packagePath = (0, path_1.dirname)(require.resolve('serverless-auto-swagger/package.json'));
            const resourcesPath = `${packagePath}/dist/resources`;
            await (0, fs_extra_1.copy)(resourcesPath, './swagger');
            if ((_a = this.serverless.service.provider.runtime) === null || _a === void 0 ? void 0 : _a.includes('python')) {
                const swaggerStr = JSON.stringify(this.swagger, null, 2)
                    .replace(/true/g, 'True')
                    .replace(/false/g, 'False')
                    .replace(/null/g, 'None');
                let swaggerPythonString = `# this file was generated by serverless-auto-swagger`;
                swaggerPythonString += `\ndocs = ${swaggerStr}`;
                await (0, helperFunctions_1.writeFile)('./swagger/swagger.py', swaggerPythonString);
            }
            else {
                await (0, fs_extra_1.copy)(resourcesPath, './swagger', {
                    filter: (src) => src.slice(-2) === 'js',
                });
                const swaggerJavaScriptString = `// this file was generated by serverless-auto-swagger
            module.exports = ${JSON.stringify(this.swagger, null, 2)};`;
                await (0, helperFunctions_1.writeFile)('./swagger/swagger.js', swaggerJavaScriptString);
            }
        };
        this.addEndpointsAndLambda = () => {
            this.serverless.service.functions = Object.assign(Object.assign({}, this.serverless.service.functions), (0, functions_1.default)(this.serverless));
        };
        this.addSwaggerPath = (functionName, http) => {
            var _a, _b, _c, _d, _e, _f, _g;
            var _h;
            if (typeof http === 'string') {
                // TODO they're using the shorthand - parse that into object.
                //  You'll also have to remove the `typeof http !== 'string'` check from the function calling this one
                return;
            }
            let path = http.path;
            if (path[0] !== '/')
                path = `/${path}`;
            (_a = (_h = this.swagger.paths)[path]) !== null && _a !== void 0 ? _a : (_h[path] = {});
            const method = http.method.toLowerCase();
            this.swagger.paths[path][method] = {
                summary: http.summary || functionName,
                description: (_b = http.description) !== null && _b !== void 0 ? _b : '',
                tags: http.swaggerTags,
                operationId: http.operationId || `${functionName}.${method}.${http.path}`,
                consumes: (_c = http.consumes) !== null && _c !== void 0 ? _c : ['application/json'],
                produces: (_d = http.produces) !== null && _d !== void 0 ? _d : ['application/json'],
                security: http.security,
                // This is actually type `HttpEvent | HttpApiEvent`, but we can lie since only HttpEvent params (or shared params) are used
                parameters: this.httpEventToParameters(http),
                responses: this.formatResponses((_e = http.responseData) !== null && _e !== void 0 ? _e : http.responses),
            };
            const apiKeyHeaders = (_g = (_f = this.serverless.service.custom) === null || _f === void 0 ? void 0 : _f.autoswagger) === null || _g === void 0 ? void 0 : _g.apiKeyHeaders;
            const security = [];
            if (apiKeyHeaders === null || apiKeyHeaders === void 0 ? void 0 : apiKeyHeaders.length) {
                security.push(apiKeyHeaders.reduce((acc, indexName) => (Object.assign(Object.assign({}, acc), { [indexName]: [] })), {}));
            }
            if (security.length) {
                this.swagger.paths[path][method].security = security;
            }
        };
        this.generatePaths = () => {
            var _a;
            const functions = (_a = this.serverless.service.functions) !== null && _a !== void 0 ? _a : {};
            Object.entries(functions).forEach(([functionName, config]) => {
                var _a;
                const events = (_a = config.events) !== null && _a !== void 0 ? _a : [];
                events
                    .map((event) => event.http || event.httpApi)
                    .filter((http) => !!http && typeof http !== 'string' && !http.exclude)
                    .forEach((http) => this.addSwaggerPath(functionName, http));
            });
        };
        this.formatResponses = (responseData) => {
            if (!responseData) {
                // could throw error
                return { 200: { description: '200 response' } };
            }
            const formatted = {};
            Object.entries(responseData).forEach(([statusCode, responseDetails]) => {
                if (typeof responseDetails == 'string') {
                    formatted[statusCode] = {
                        description: responseDetails,
                    };
                    return;
                }
                const response = { description: responseDetails.description || `${statusCode} response` };
                if (responseDetails.bodyType) {
                    response.schema = { $ref: `#/definitions/${responseDetails.bodyType}` };
                }
                formatted[statusCode] = response;
            });
            return formatted;
        };
        // httpEventToSecurity = (http: EitherHttpEvent) => {
        //   // TODO - add security sections
        //   return undefined
        // }
        this.pathToParam = (pathParam, paramInfoOrRequired) => {
            var _a;
            const isObj = typeof paramInfoOrRequired === 'object';
            const required = (_a = (isObj ? paramInfoOrRequired.required : paramInfoOrRequired)) !== null && _a !== void 0 ? _a : true;
            return {
                name: pathParam,
                in: 'path',
                required,
                description: isObj ? paramInfoOrRequired.description : undefined,
                type: 'string',
            };
        };
        // The arg is actually type `HttpEvent | HttpApiEvent`, but we only use it if it has httpEvent props (or shared props),
        //  so we can lie to the compiler to make typing simpler
        this.httpEventToParameters = (httpEvent) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const parameters = [];
            if (httpEvent.bodyType) {
                parameters.push({
                    in: 'body',
                    name: 'body',
                    description: 'Body required in the request',
                    required: true,
                    schema: { $ref: `#/definitions/${httpEvent.bodyType}` },
                });
            }
            const rawPathParams = (_b = (_a = httpEvent.request) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 : _b.paths;
            const match = httpEvent.path.match(/[^{}]+(?=})/g);
            let pathParameters = match !== null && match !== void 0 ? match : [];
            if (rawPathParams) {
                Object.entries(rawPathParams !== null && rawPathParams !== void 0 ? rawPathParams : {}).forEach(([param, paramInfo]) => {
                    parameters.push(this.pathToParam(param, paramInfo));
                    pathParameters = (0, helperFunctions_1.removeStringFromArray)(pathParameters, param);
                });
            }
            // If no match, will just be [] anyway
            pathParameters.forEach((param) => parameters.push(this.pathToParam(param)));
            if (httpEvent.headerParameters || ((_d = (_c = httpEvent.request) === null || _c === void 0 ? void 0 : _c.parameters) === null || _d === void 0 ? void 0 : _d.headers)) {
                // If no headerParameters are provided, try to use the builtin headers
                const rawHeaderParams = (_e = httpEvent.headerParameters) !== null && _e !== void 0 ? _e : Object.entries(httpEvent.request.parameters.headers).reduce((acc, [name, required]) => (Object.assign(Object.assign({}, acc), { [name]: { required, type: 'string' } })), {});
                Object.entries(rawHeaderParams).forEach(([param, data]) => {
                    var _a, _b;
                    parameters.push({
                        in: 'header',
                        name: param,
                        required: (_a = data.required) !== null && _a !== void 0 ? _a : false,
                        type: (_b = data.type) !== null && _b !== void 0 ? _b : 'string',
                        description: data.description,
                    });
                });
            }
            if (httpEvent.queryStringParameters || ((_g = (_f = httpEvent.request) === null || _f === void 0 ? void 0 : _f.parameters) === null || _g === void 0 ? void 0 : _g.querystrings)) {
                // If no queryStringParameters are provided, try to use the builtin query strings
                const rawQueryParams = (_h = httpEvent.queryStringParameters) !== null && _h !== void 0 ? _h : Object.entries(httpEvent.request.parameters.querystrings).reduce((acc, [name, required]) => (Object.assign(Object.assign({}, acc), { [name]: { required, type: 'string' } })), {});
                Object.entries(rawQueryParams).forEach(([param, data]) => {
                    var _a, _b;
                    parameters.push(Object.assign({ in: 'query', name: param, type: (_a = data.type) !== null && _a !== void 0 ? _a : 'string', description: data.description, required: (_b = data.required) !== null && _b !== void 0 ? _b : false }, (data.type === 'array'
                        ? {
                            items: { type: data.arrayItemsType },
                            collectionFormat: 'multi',
                        }
                        : {})));
                });
            }
            return parameters;
        };
        this.serverless = serverless;
        this.options = options;
        if (io === null || io === void 0 ? void 0 : io.log)
            this.log = io.log;
        else
            this.log = {
                notice: (_b = (_a = this.serverless.cli) === null || _a === void 0 ? void 0 : _a.log) !== null && _b !== void 0 ? _b : console.log,
                error: console.error,
            };
        this.registerOptions();
        this.commands = {
            'generate-swagger': {
                usage: 'Generates Swagger for your API',
                lifecycleEvents: ['generateSwagger'],
            },
        };
        this.hooks = {
            'generate-swagger:generateSwagger': this.generateSwagger,
            'before:offline:start:init': this.preDeploy,
            'before:package:cleanup': this.preDeploy,
        };
    }
}
exports.default = ServerlessAutoSwagger;
